# Техническое Задание: Разработка ядра SillyInnkeeper

## 1. Обзор проекта

**SillyInnkeeper** — это локальный менеджер для организации коллекций карточек персонажей SillyTavern.
**Главная проблема:** Оригинальный интерфейс SillyTavern испытывает критические проблемы с производительностью при наличии 1000+ карточек (лаги DOM, долгое чтение файлов).
**Задача:** Создать высокопроизводительный бекенд, который сканирует файловую систему, кэширует метаданные в SQLite и отдает фронтенду легкие JSON-ответы и оптимизированные миниатюры.

## 2. Технологический стек (Строго)

Агент обязан использовать только указанные библиотеки:

- **Сервер:** `fastify`, `@fastify/autoload`, `@fastify/sensible`, `fastify-plugin`.
- **База данных:** `better-sqlite3` (Синхронный драйвер, режим WAL).
- **Файловая система:** `fs-extra` (управление файлами), `chokidar` (отслеживание изменений).
- **Изображения:**
  - `pngjs`: **Только** для чтения текстовых чанков (`tEXt`) из PNG без полного декодирования изображения (для скорости).
  - `sharp`: Для генерации уменьшенных копий (thumbnails) в формат `.webp`.

## 3. Управление настройками

Настройки хранятся в JSON файле.

- **Путь:** `./data/settings.json`.
- **Структура:**
  ```json
  {
    "cardsFolderPath": "F:\\SillyTavern\\public\\characters" // Может быть null при первом старте
    // ...
  }
  ```
- **Поведение:**
  1.  При старте сервера прочитать этот файл.
  2.  Если `cardsFolderPath` валиден и папка существует -> Запустить процесс сканирования.
  3.  Если путь не валиден -> Ожидать вызова API для обновления настроек.

## 4. База данных (SQLite)

Используем **Гибридную схему**: часто используемые поля — в колонках, вся остальная спецификация — в JSON-blob.

### Таблица `cards` (Метаданные)

Хранит уникальные сущности карточек.

- `id` (TEXT, PK): UUID v4.
- `name` (TEXT): Имя персонажа (для сортировки).
- `description` (TEXT): Краткое описание (для поиска).
- `tags` (TEXT): JSON-массив тегов (например `["elf", "female"]`) для фильтрации.
- `creator` (TEXT): Автор карточки.
- `spec_version` (TEXT): Версия спецификации (`2.0`, `3.0`).
- `avatar_path` (TEXT): Относительный путь к сгенерированному WebP файлу в папке `.cache`.
- `created_at` (INTEGER): Timestamp создания записи.
- **`data_json` (TEXT)**: Полный сериализованный JSON-объект поля `data` из карточки. Содержит V3 поля (`character_book`, `assets`, `scenario`, `first_mes` и т.д.).

### Таблица `card_files` (Физические файлы)

Реализует связь "Один ко многим" для обработки дубликатов.

- `file_path` (TEXT, PK): Полный абсолютный путь к файлу на диске.
- `card_id` (TEXT, FK): Ссылка на `cards.id`. `ON DELETE CASCADE`.
- `file_mtime` (INTEGER): Время последней модификации файла (ms).
- `file_size` (INTEGER): Размер файла в байтах.

## 5. Сервис сканирования (Core Logic)

Создать сервис `ScanService`, который работает по следующему алгоритму:

### А. Чтение метаданных (Парсинг)

1.  Использовать `fs.createReadStream` + `pngjs` (парсинг чанков).
2.  Найти чанк типа `tEXt`.
3.  Искать ключевое слово (keyword): `chara` (стандарт).
4.  Декодировать содержимое из Base64 в JSON.
5.  Определить версию (V2 или V3).

### Б. Генерация Thumbnails

1.  Использовать `sharp`.
2.  Вход: Исходный PNG.
3.  Операция: `resize({ width: 300 })` -> `toFormat('webp')`.
4.  Выход: Сохранить в папку `./data/cache/thumbnails/{uuid}.webp`.

### В. Алгоритм Синхронизации (Reconciliation)

Сканирование запускается рекурсивно для указанной папки. Для каждого найденного `.png`:

1.  **Проверка изменений:**

    - Проверить наличие `file_path` в таблице `card_files`.
    - Если запись есть, сравнить `file_mtime` и `file_size`.
    - Если совпадают -> **Пропустить** (файл не изменился).

2.  **Обработка Нового/Измененного файла:**

    - Распарсить метаданные (см. пункт А).
    - **Проверка дубликатов:** Проверить, существует ли уже карточка с таким же именем и описанием (или вычислить хеш картинки, если решишь добавить поле хеша). _Для простоты MVP: генерируем новый UUID для каждого уникального набора метаданных._
    - Сгенерировать миниатюру (см. пункт Б).
    - **INSERT/UPDATE:**
      - Записать данные в `cards`. В поле `data_json` положить весь объект `data` целиком.
      - В поля `name`, `tags`, `description` вынести соответствующие значения для быстрого поиска.
      - Записать путь в `card_files`.

3.  **Очистка удаленных:**
    - После сканирования найти записи в БД, путей которых больше нет на диске.
    - Удалить их из `card_files`.
    - Если у `cards` не осталось связанных файлов -> удалить карточку и её миниатюру.

**Важно:** Операции парсинга и sharp должны выполняться с ограничением конкурентности (используй `p-limit` или аналог, макс 5 потоков), чтобы не завис сервер.

## 6. API Endpoints (Fastify Routes)

Все ответы должны быть в формате JSON.

### 1. Settings

- `GET /api/settings`: Получить текущие настройки.
- `put /api/settings`: Обновить `cardsFolderPath`. При обновлении запускать ре-скан.

### 2. Cards (Список)

- `GET /api/cards`
- **Требование к производительности:** В SQL запросе выбирать **ТОЛЬКО** легкие колонки! Не запрашивать `data_json`.
- **Ответ:**
  ```json
  [
    {
      "id": "uuid",
      "name": "Eldarion",
      "tags": ["elf", "rpg"],
      "creator": "Anon",
      "avatar_url": "/api/thumbnail/{id}", // Ссылка на роут
      "file_path": "F:/..." // Берем первый доступный путь из card_files
    },
    ...
  ]
  ```

### 3. Card Details (Детально)

- `GET /api/cards/:id`
- **Логика:**
  1.  `SELECT * FROM cards WHERE id = ?`.
  2.  Распарсить `data_json`.
  3.  Сформировать полный ответ, объединив системные поля и данные спецификации.
- **Ответ:**
  ```json
  {
    "id": "uuid",
    "spec": "chara_card_v3",
    "file_path": "...",
    "data": { ...полный объект V3... }
  }
  ```

### 4. Assets

- `GET /api/thumbnail/:id`
  - Найти `avatar_path` в БД. Стримить файл `.webp` с диска.
- `GET /api/image/:id`
  - Найти `file_path` в таблице `card_files`. Стримить оригинальный PNG.

## 7. Обработка ошибок

- Если PNG файл битый и `pngjs` падает с ошибкой -> Логировать ошибку (`console.error`), пропускать файл, не останавливать сканирование.
- Если папка настроек недоступна -> Возвращать понятную ошибку в API, но не крашить процесс.
